_package xsd_loader

_block
	remex(:xsd_loader)
_endblock
$

def_slotted_exemplar(
	:xsd_loader,
	{
		{:types, _unset, :readable, :public}
	})
$

_pragma(classify_level=basic, topic={xsd_loader, xsd})
_method xsd_loader.new(p_types)
	##
	_return _clone.init(p_types)
_endmethod
$

_pragma(classify_level=basic, topic={xsd_loader, xsd})
_private _method xsd_loader.init(p_types)
	##
	.types << p_types
	_return _self
_endmethod
$

_pragma(classify_level=basic, topic={xsd_loader, xsd})
_method xsd_loader.load_xml_from_file(p_filename)
	## Load and convert an XML file conforming to the loaded XSD
	## Creates in-memory objects from the XML, derived from the XSD
	l_simple_xml << simple_xml.new(:process_ns?, _true)
	l_xml << l_simple_xml.read_document_file(p_filename)
	
	# parse XML, transforming elements to objects
	_return _self.load_xml_thing(l_xml.top_element)
_endmethod
$

_pragma(classify_level=basic, topic={xsd_loader, xsd})
_method xsd_loader.load_xml_from_string(p_xml_string)
	## Load and convert an XML string conforming to the loaded XSD
	## Creates in-memory objects from the XML, derived from the XSD
	l_simple_xml << simple_xml.new(:process_ns?, _true)
	l_xml << l_simple_xml.read_document_string(p_filename)
	
	# parse XML, transforming elements to objects
	_return _self.load_xml_thing(l_xml.top_element)
_endmethod
$

_pragma(classify_level=basic, topic={xsd_loader, xsd})
_private _method xsd_loader.load_xml_thing(p_xml_thing, _optional p_magik_type)
	##
	# get target type
	l_magik_type << _if p_magik_type _isnt _unset
			_then
				>> p_magik_type
			_else
				l_namespace << p_xml_thing.uri
				l_name << p_xml_thing.local_name
				>> .types[{l_namespace, l_name}]
			_endif
	
	# parse children
	l_props << property_list.new()
	_for i_xml_child _over p_xml_thing.xml_elements.fast_elements()
	_loop
		(l_child_name, l_child) << _self.parse_xml_child(i_xml_child, l_magik_type)
		
		_if l_props[l_child_name] _is _unset
		_then
			l_props[l_child_name] << rope.new()
		_endif
		l_props[l_child_name].add_last(l_child)
	_endloop
	
	# instantiate object
	_return l_magik_type.new(l_props)
_endmethod
$

_pragma(classify_level=basic, topic={xsd_loader, xsd})
_private _method xsd_loader.parse_xml_child(p_xml_child, p_parent_type)
	##
	l_child_name << _self.generate_slot_name(p_xml_child.local_name).as_symbol()
	l_child_field_type << p_parent_type.field_types[l_child_name]
	l_child_magik_type << l_child_field_type[:type]
	l_child << _if l_child_magik_type _is _unset
		   _then
			   >> p_xml_child.xml_contents
		   _elif l_child_magik_type.is_kind_of?(xsd_simple_type)
		   _then
			   >> l_child_magik_type.new(p_xml_child.xml_contents)
		   _elif l_child_magik_type.is_kind_of?(xsd_complex_type)
		   _then
			   >> _self.load_xml_thing(p_xml_child, l_child_magik_type)
		   _endif
	
	_return l_child_name, l_child
_endmethod
$

_pragma(classify_level=basic, topic={xsd_loader, xsd})
_private _method xsd_loader.generate_slot_name(p_name)
	##
	# XXX TODO: follow xsd_loader_factory, don't make up own slot name
	l_snake_case << p_name.write_string.as_snake_case()
	_return l_snake_case.as_symbol()
_endmethod
$
